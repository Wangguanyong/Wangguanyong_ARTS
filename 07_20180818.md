## Algorithm
### [Container With Most Water](https://leetcode.com/problems/container-with-most-water/description/)
```
class Solution {
    public:
        int maxArea(vector<int>& height) {
            int maxArea = 0;
            for(int i = 0; i < height.size(); ++i)
            {
                for(int j = i + 1; j < height.size(); ++j)
                {   
                    int len = j - i;
                    int hei = std::min(height[i], height[j]);
                    int area = len * hei;
                    if(area > maxArea)
                    {   
                        maxArea = area;
                    }
                }
            }

            return maxArea;
        }
};
```

## Review
### [A plain english introduction to CAP Theorem](http://ksat.me/a-plain-english-introduction-to-cap-theorem/)
这是一篇关于分布式系统中cap理论的通俗的一个讲解。作者通过一个简单的例子（如何设计一本备忘录业务）来讲解了cap理论基础。
1. 一致性(consistent)：当设计一个备忘录时，如果有多个使用者可以来更新备忘录，如果每个使用者都去维护自己的一个备忘录副本，那么不同使用者的备忘录会不一致。那么如果a去b的备忘录查询结果，就无法查询到正确的记录。这里的关键是每个用户都有一个自己的备忘录副本，各个副本不一致。为了解决这个问题，不同用户的备忘录更新时，都要去保证其他用户更改自己的备忘录，这样就可以达到备忘录一致的状态。但是如果每个使用者有更新都需要保证其他使用者更新当前备忘录，会造成新的问题。
2.  可用性（availability），如果一个使用者并不能正常工作，但是这时候如果有一个更新操作，但是这个更新操作要保证其他使用者更新自己的备忘录，这个时候这个更新操作就永远不会完成，即当前系统无法正常工作了。为了解决这个问题，可以不用非得要保证其他使用者必须更新当前的备忘录，可以在更新的时候写下更新的日志，当其他使用者上线时，去查看日志，同时跟自己的记录做对比，可以保证恢复到最新的状态。也可以解决可用性的问题。但是这里有一个问题，更新是有需要时间的，更新操作在这里其实不是绝对的一致的，如果系统能够忍受这个不一致性，是可以的。比如说我们的留言系统，并不要求一个留言即刻能被所有用户看到，是允许有一个时间差的。
3.  分区容错（Partition tolerant）：前边的可用性和一致性能够正常工作的前提是各个用户都遵循规则， 当有更新的时候都去写更新日志，上线时都去读取日志更新自己的记录。但是如果某个使用者不遵循这个规则，不去写更新日志，也不去读取日志，即不能正常工作，那么整个系统又无法正常工作了。除非能够修复好这个不能正产工作的部分。

因此可以得出一个结论，分布式系统中的三个目标cap不能同时达到，一般设计系统会取舍完成1个或者两个目标。

## Technique
分享一个我在工作中遇到的一个比较有意思的问题和解决方法。</br>
在开发中，使用了protobuf做消息协议，同时使用了mongodb作为数据库。使用c\++作为开发语言。在实际工作中，有很多的protobuf定义的消息对象需要存储到mongodb中，但是c++语言中写存储过程是一个比较麻烦的事情，需要一个字段一个字段的填写，很是复杂而且容易出错，特别是对嵌套层数较深的情况更是如此。但是在java中有ORM这个东西，可以直接将对象映射承数据库中的记录。但是c\++中没有中东西可用。</br>
我发现mongodb的document其实是一个类似于json格式的字符串，而protobuf也提供了反射功能，可以动态的构建字段，因此从理论上来说我认为他们是可以做到自动转换的，通过查阅相关接口，终于完成了protobuf到mongodb中插入document的自动转换，极大的节省了时间和减轻了工作量。
## Share
这次分享一下一个失败的面试记录。面试岗位是腾讯的后台开发。
技术面试问的问题其实比较基础，没有太多高深的东西。但是这次面试提问者的技巧很好，没有明白的说是那个知识点，而是结合着一些场景来问，我认为还是比较专业的。</br>
比如说问软件设计的方面的问题，问如果有新的需求来了，如何在现有代码中完成新功能的开发。其实这个问题我平时没有认真思考过，就按照自己平时所做的答复了，大意就是要遵循当前程序的框架结构，不能为了一个需求去对现有结构做大的调整，造成更多的bug。如果这个需求比较急，也可以用一些比较取巧的方法暂时完成，等后续再完善代码。后来的面试评语缺点部分主要就是：虽然对软件设计有自己的想，但是没有系统的代码设计知识。
后来我看了一下设计模式的原则，这个其实是设计模式中的“开闭原则”， 即对添加开放，对修改闭合。</br>
还有一个问题我印象比较深刻是问epoll的两种模式，这个我有学习没有问题，但是他又接着问了了这两种模式的应用场景。实话说我平时只用到了水平模式，因为只是对读写事件感兴趣，没想到脉冲模式的应用场景，当时也没有仔细想想，就说了不知道。结果我刚出大楼就想起定时器这个应用。所以面试的时候不要紧张，还是应该仔细思考，这个问题其实不难，平时要多积累，多思考，不能只看到书表面上的知识点。</br>
这次面试虽然失败了，但是也有好的一面，总算是经过了大公司的面试过程，对自身的不足有了一个初步的认识。



