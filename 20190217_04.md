## Algorithm
### [151. Reverse Words in a String](https://leetcode.com/problems/reverse-words-in-a-string/)

```
class Solution {
    public:
        void reverseWords(string &s) {
            std::stack<std::string> strStack;
            const char *pStart = s.c_str();
            const char *pTarget = NULL;

            while((pTarget = std::strstr(pStart, " ")) != NULL)
            {
                if(pTarget == pStart)
                {
                    pStart++;
                }
                else
                {
                    std::string word(pStart, pTarget - pStart);
                    strStack.push(word);
                    pStart = pTarget + 1;
                }
            }

            if(pStart <= &s[s.size() - 1])
            {
                std::string lastWord(pStart);
                strStack.push(lastWord);
            }


            std::string result;
            while(!strStack.empty())
            {
                result += strStack.top();
                if(strStack.size() != 1)
                    result += " ";
                strStack.pop();
            }

            s = result;
        }
};
```
## Review
### [What is Cloud-Native? Is It Hype or The Future of Software Development?](https://stackify.com/cloud-native/)
一直听说云原生计算，却不知道这个是怎么回事，读了一篇入门的介绍文章，可以大概了解一下。</br>
云原生计算利用云计算的能力，可以快速的架设与大规模的扩展，同时节约成本。其基础是容器技术，编排技术及微服务架构。其具有如下三个特征
1. 容器化。
2. 动态编排。
3. 面向微服务</br>
容器技术，比如docker，将应用及其所依赖的环境打包成一个单独的可执行文件，这个可执行文件可以在虚拟化的环境中运行，可以拜托应用与运行环境之间的依赖关系，可以很方便的进行开发测试，部署应用工作。</br>
容器编排：生产环境中服务种类繁多，机器数量巨大，需求复杂多变，如果靠人力去监控维护这些服务将十分的复杂。可以借助容器编排技术来完成这些工作，包括：
1. 系统监控。
2. 容器的启停。
3. 配置参数。
4. 容器间的鉴权服务。

微服务：上述的两种技术只是基础设施，微服务则是一种新的应用设计方法，其将传统的单体程序拆分，各个子程序以对外提供较为单一的服务，由多个服务共同构成应用。将传统单体程序拆分成各个小服务，降低了各个部分的耦合度，有利于大型应用的设计开发。同时微服务的方式也有利于服务的动态扩展，当某项服务容量不能满足时， 可以快速扩展部署应用以满足需求，而应用中其他部分可以保持不变，这相对于传统单体应用可以很好的节约成本。</br>
微服务虽然有上述的优点，但是微服务构建的分布式系统天生具有很高的复杂性，给监控、通信、管理都带来了困难。

## Tech
### 索引基础
#### index类型
#### 1. B-tree索引
B-tree索引利用B-Tree树进行数据组织，数据是有序排列的，查找时不需要全表扫描，从根节点开始进行搜索，节点中存放了指向子节点的指针，这些指针定义了子节点中值得上限和下限。叶子节点存放的是数据。这就特别适合范围查找数据。</br>
B-tree索引的查询类型：a. 全值匹配。b.匹配最左前缀。c.匹配列前缀。d.匹配范围值。e.精确匹配某一列并范围匹配另一列。f.只访问索引的查询。</br>
查询限制：必须按照最左列开始查找;不能跳过索引中的列；某个列有范围查询，则其右边所有列都无法使用索引优化查询。
#### 2. Hash索引
hash index 基于hash表实现。只有精确匹配索引才能查询有效。hash索引无法排序，也不支持部分索引匹配查找。不支持范围查找，hash冲突严重时会降低性能。</br>
自适应hash索引：InnoDB引擎注意到某些索引值被使用的非常频繁时， 会在B-tree基础之上再创建一个hash索引加快寻找速度。
#### 3.空间数据索引
可以从所有维度来索引数据。
#### 4.全文索引

### 索引的优点
1. 大大减少服务器需要扫描的数据量
2. 索引可以帮助服务器避免排序和临时表
3. 索引可以将随机I/O变为顺序I/O

### 高性能的索引策略
#### 1.独立的列
索引列不能是表达式的一部分
#### 2. 前缀索引和索引选择性
对较长的字符串建立index，成本较高，可以选择开始部分字符建立index，但需要平衡选择性和成本。主要是计算选择完整性较高时候的前缀长度。
#### 3. 多列索引
为每个列创建独立索引是错误的做法。</br>
#### 4.选择合适的索引列顺序
正确的顺序依赖于使用该索引的查询，并且同时需要考虑如何更好的满足排序和分组的需要。</br>
经验法则:将选择性最高的列放在索引列最前。(并不一定正确),不如避免随机I/O和排序那么重要。

#### 5. 聚簇索引
聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。值在同一个结构中保存了B-Tree索引和数据行。当表有聚簇索引时，它的数据行实际上市存放在索引的叶子节点中的。聚簇表示数据行和键值紧凑的存储在一起。一个表只能有一个聚簇索引。</br>
优点：1. 可以把相关数据保存在一起，提高I/O效率。2.数据访问更快。3.使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</br>
缺点:1. 如果数据全部在内存中，则聚簇索引没有优点。2.插入速度严重依赖于插入顺序，顺序插入式最快的方式。(optimize table从新组织表)。3.更新聚簇索引的代价较高，因为会强制InnoDB将每个被更新的行移动到新的位置。4.基于聚簇缩影的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临"页分裂",占用更多的磁盘空间。5. 聚簇索引可能导致全表扫描变慢。
6.非聚簇索引可能会变大，因为非聚簇索引的叶子节点包含了引用行的主键列。</br>
二级索引中叶子节点存储主键值而不是指针，可以减少维护的成本。在InnoDB中按主键顺序插入数据较好，避免随机的id作为主键，会使得索引的插入变得完全随机，使得数据没有聚集特性，插入时间变大，同时导致页分裂产生碎片，增大磁盘空间。</br>

#### 6.覆盖索引
如果一个索引包含所有需要查询的字段的值，就称之为覆盖索引。覆盖索引查询只需要扫描索引不需要回表，查询效率会提高。覆盖索引要存储索引列的值，因此只能使用B-Tree来做覆盖索引。

#### 7.使用索引扫描来做排序
mysql有两种方式排序：1. 通过排序操作。2.按照索引顺序扫描。</br>
按索引顺序读取数据的速度通常比顺序地全表扫描慢。因为如果索引不能覆盖所有数据，则每次读取一行就要回表查询一行数据。一个好的索引要既能满足排序，又能用于查找行。只有当索引的列顺序和order by子句的顺序完全一致，并且所有列的排序方向都一样是，MySQL才能使用索引来对结果进行排序。order by子句和查询的限制是一样的:需要满足索引的最左前缀的要求，否则，就不能利用索引排序。除非order by子句的前导列为常量。

#### 8. 前缀压缩索引
#### 9. 冗余和重复索引
MySQL允许在相同列上创建多个索引，mysql会单独维护重复索引。重复索引应该避免并消除。
#### 10.未使用的索引
未使用的索引应该删除。
#### 11. 索引和锁
索引可以使查询锁定更少的行。锁定超过需要的行会增加锁争用并减少并发性。InnoDB在二级索引上使用共享锁，但访问主键索引时需要排他锁。
## Share
最近虽然在看书，看的越多就发现不懂得更多，虽然还是在坚持看书看专栏，但是感觉看的知识不能串联起来，都是一个一个孤立的点。这种方式感觉比较低效，经常是看了后边忘了前边。</br>
说到底还是知识没有消化，有些基础的概念性的知识是需要花时间通过看书去消化的。但是一些实操性质的技能还是需要去动手才能消化。前边有实操动手学习，感觉也比较吃力，不懂的东西太多了，磕磕绊绊也弄不出来，虽然通过google可以解决，往往是花费了大量时间也没有搞清楚是为什么。</br>
这样看来还是书没看够，基础的东西还不了解，实操也很打击信心。现在要学的东西太多了，java,spring boot,微服务，算法，数据库。每一个都是需要大量时间投入的项目。不过也不用太着急，我开始学这些的时间也才3 4个月而已，速成还是不太可能，后续通过专栏，把基础打好，在结合实际操作，应该还是没有问题的。

