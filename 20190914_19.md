## Algorithmn
### [621. Task Scheduler](https://leetcode.com/problems/task-scheduler/)
```
class Solution {
    public:
        int leastInterval(vector<char>& tasks, int n) {
            int m[128] = {0};
            for (char c : tasks)  m[c]++;  
            sort(m, m + 128, [](int a, int b){ return a > b; });
            int gap = n * (m[0] - 1), total = m[0] + gap;
            for (int i=1; i<128 && m[i] != 0; i++) {
                if (gap >= m[i]) {
                    if (m[i] == m[0]) {
                        gap -= (m[0] - 1);      
                        total++;
                    } else {
                        gap -= m[i];
                    }
                } else {
                    return tasks.size();
                }
            } 
            return total;
        }
};
```
## Review
### [Some study on database storage internals](https://medium.com/@kousiknath/data-structures-database-storage-internals-1f5ed3619d43)
这篇文章讲述了数据库的索引设计的原理。

计算机存储结构中，内存（RAM）速度快，但是容量有限。硬盘（disk）速度慢但是容量大。因此不会讲所有数据放入内存，而是在需要的时候才将数据从硬盘调入内存。但是硬盘的读写成本高，因此如何用最少次数的读写找到所需的数据，是数据结构设计的重要一环。硬盘是按照页为单位进行管理的，每次可以读取多个也进入内存，因此一般数据库会利用B+数来组织数据。B+数类似于B数，但是每个node会有多个叶子节点组成一个页，读取是按照页为单位进行。B+数的中间节点不存具体数据，存储导航信息，可以快速定位到数据页的位置，减少磁盘查找次数，利用数据的局部性原理，也可减少数据的读取次数。同时B+数结构天然支持范围查找。

以下连个关于B+的准则可以提高数据库的性能：
1. 减少索引的数量。索引的维护是有成本的，过多的索引不仅会占用存储空间，还会导致数据的写入变慢，页的分裂问题。
2. 顺序插入：按照主键索引的顺序插入数据，当前数据页就在内存中，可以减少数据页从硬盘页调入的开销，同时批量插入后一次刷盘可以节省IO时间，提高效率。

B+数利用缓存、索引可以提高数据的读取效率，但是对于数据的随机写则不是一个很好的选择。在现代的聊天应用，实时沟通，IOT场景，数据写入量非常大。如何保证数据快速写入的同时能够快速检索数据是需要解决的问题。传统数据库无法满足这种高可用，最终一致性及非结构化数据以及时延要求场景。

LSM（Log Structured Merge Tree)是上述场景的一种解决方法。LSM不像B树一样是一种数据结构。当数据写入磁盘后就不会更改，因此采用顺序写入的方式，只是在数据流后添加写入的数据。利用现代的SSD设备，可以保证写入的速度。
Fractal Tree Index(分形树索引)：数据库的插入更新操作并不会立即执行，而是将操作动作存放在中间节点，由后续的步骤完成实际的操作。

## Tech
#### 怎么排查慢查询
1. 有几个参数设置，可以获取到慢查询的日志：
- slow_query_log: 是否开启慢查询日志，开启则会获取执行时间超过一定值得语句
- long_query_time:慢查询的时间，超过此时间则会记录慢查询日志
- slow_query_log_file: 慢查询日志文件名
- long_queries_not_using_indexes:设置为on，可以捕获所有未使用索引的SQL语句。

2. SHOW PROCESSLIST命令。</br>
    ID, USER, HOST, DB, COMMAND, TIME, STATE, INFO </br>
state 列的状态可以表示当前处于什么状态。(checking table, closing table, connect out, creating tmp table, deleting from main table, flushing table...)

    3. EXPLAIN 语句
    explain显示了mysql如何使用索引来处理select语句以及连接表，可以帮助选择更好的索引和写出更优化的查询语句。</br>
    - table: 关于那张表
    - possible_key: 可能应用在这张表中的索引。
    - type: 显示连接用的哪种类型(const, eq_ref, ref, range, index和all)
    - key:实际使用的索引
    - key_len:索引长度
    - ref:显示索引那一列被使用
    - rows: MYSQL认为必须检查的用来返回请求数据的行数
    - Extra：额外信息，using temporary及using filesort表示不适用索引。

## Share
### 限流算法

1. 定时算法，即在开始时记下一个时刻，并维持一个计数器counter。当一个请求到来时，就将计数器+1，同时计算此刻时间与初始时间的差值diff，若counter/diff>threashold。则表明超限。这种方法简单，成本低，但是有一个很大的缺点：如果限流100/h，如果在59min发送100次，在01min又发送了100次，则在紧挨着的2min内发送了200次，绕过了这个限制。
2. 滑动窗口。定时算法的缺陷在与统计周期太粗，如果把1个小时划分成60min，每1min内进行一次计算，每过1min钟就更新窗口(减去第一个窗口，新增一个窗口)，那么按照这些窗口一并统计，可以减小统计的粒度，使得流量控制更为平滑。
3. 漏桶算法：这个算法的原理是加水即请求速度是不定的，但是水桶漏水即后端处理的请求速率一定，水桶是一个队列。当请求量大，水桶就缓冲请求，当队列满时就丢弃新来的请求，由漏水速度控制流量。
4. 令牌算法，维护一个队列，令牌发放程序按照一定速度下发令牌，请求到来时必须要获取到令牌才能获得处理，令牌用一个队列维护，当队列满时就丢弃令牌。通过令牌的存储及发放来控制流量。令牌算法和漏桶算法的区别在于漏桶算法始终只能按照一定的速率被处理，令牌算法可以存储一部分令牌，当流量突然增大时，可以获得一部分的处理，当令牌被消耗完，则也只能按照令牌发放的速度处理。
5. 滑动次数方法：维护一个队列，队列大小为需要限制的次数，比如1000/min,每次来时记录次数及时刻,每到一个请求，更新队列，用时间减去初始时刻值，得到时间差，此时如果未达到限流条件，则更新队列。如果达到限流条件，则丢弃。这种方法较为精确的实现了限流，但是成本较高，需要每个用户维护一个较大的请求队列记录。

