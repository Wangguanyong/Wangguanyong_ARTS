## Algorithm
#### [234. Palindrome Linked List](https://leetcode.com/problems/palindrome-linked-list/submissions/)
```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
    public:
        bool isPalindrome(ListNode* head) {
            if(head == NULL)
            {
                return true;
            }
            ListNode* pFast = head;
            ListNode* pSlow = head;

            std::stack<int> stack;
            while(pFast != NULL && pFast->next != NULL)
            {
                pFast = pFast->next;
                pFast = pFast->next;
                stack.push(pSlow->val);
                pSlow = pSlow->next;
            }

            if(NULL != pFast)
            {
                pSlow = pSlow->next;
            }

            while(pSlow)
            {
                int top = stack.top();
                if(top != pSlow->val)
                {
                    return false;
                }
                stack.pop();
                pSlow = pSlow->next;
            }

            return true;
        }
};
```
这道题是寻找判断一个链表是否是回文的，即是否在中间点是对称的。这里首先需要找到中间点，然后沿着这个点向两头走，分别判断值是否一致。寻找中间点可以使用两个指针，快指针步长为2，这样当快指针走到尾时，慢指针刚好走到中间，这里需要区分奇数和偶数的不同情况。用快指针的最后位置判断是奇数还是偶数。

## Review
#### [How to Learn Effectively](https://medium.com/@aakashns/how-to-learn-effectively-11050d9bf1cc)

这篇文章讲述了三个方面：1. 如何有效的学习。2. 如何记忆。3. 如何“治疗”拖延症。

我们的大脑有两种思维模式：1. 专注模式，在这种模式下，我们思维集中，在一个小范围内进行高强度的思考练习，形成条件反射般的思维模式，比如我们在学习技能，解决难题的时候就是处于这种模式。2. 发散模式，此时我们思维是分散的，并没有专心想某个问题或者其他，比如散步，睡觉的时候就是这种模式。为了高效学习，需要合理的利用这两种模式。比如在我们学习，工作时就要避免注意力的分散。而在休息时，一些奇思妙想可能会从我们的头脑中冒出来，解决我们平时遇到的问题。

人在工作时会用到头脑中的知识，人在某一时刻能够记起的知识数量是有限的，就像一台计算机的内存是一定的，如何能够存储更多的东西呢，如何能够记起更多的知识用于解决问题呢？作者这里提出了一个办法：形成记忆知识块。知识点如果太分散，知识之间缺乏联系，那么记忆就并不牢固且持久，如果我们只是保存知识的“索引”，即建立起知识的```关联性```，关于知识的细节在这些索引之下，那么我们就能顺着建立起的联系来“顺藤摸瓜”，达到记忆的持久性。当然，这并不是一劳永逸的，需要我们建立在理解的基础之上，并且通过大量的练习，特别是针对困难点的练习，回顾来加强这种记忆。总之，```建立联系，练习，回顾```是提高学习，建立稳固记忆的一种有效方法。

克服拖延症。拖延症就是在着手任务时，由于某个诱因，比如不舒服的感觉，导致注意力条件反射的转移到让自己舒服的事情上去了，比如上网，看剧等。等到时间快要结束的时候才猛赶时间完成任务，造成心理上的愧疚感。要克服拖延症，需要制定工作计划，并严格执行。在碰到使自己不舒服的事情时，要有意的克服这种本能的注意力分散，而是按照计划严格执行，采用番茄工作法，在设定的时间内坚决不被打断，按时完成工作，并且在工作结束后给自己一定的奖励。拖延症感觉每个人都有，要克服拖延症就是克服人性，做一些反人性的事情，制定目标并严格执行，就能有效的克服拖延症。

## Tech
### 概念
在linux系统中，“everything is file.”。常规的文件，/dev下的各种设备，/proc下的系统信息，/dev/random随机数生成器等虽然功能各不相同，但是在linux中都统统被抽象为了文件，可以通过统一的文件操作方法进行使用。用户使用文件路径名来指定一个文件，但是在os内部，却不是这样，其通过一个称为inode的结构体来访问文件，即文件的内容是存放在磁盘的单独的块中，inode作为文件的管理文件，管理文件的各种属性，包括名称，文件大小，访问权限，修改时间等信息。因此，inode是包含文件的元数据，包括文件名，文件大小，访问权限，所属组，所属用户， 时间戳，block位置，链接数。stat命令用于查看inode信息。一个目录其实也是一个文件，文件类似于一个数组，其中存储着文件名：inode number键值对pair，我们通过一个文件名就可以找到对应的inode number，从而找到inode结构体。比如说，ls -i命令就可以查看当前目录下的文件及对应的inode number。而stat file可以查看对应file的inode结构体信息。

在磁盘初始化时， 会在磁盘中创建数据区和inode区， 一个磁盘的inode节点的总数在初始化时就已经确定，可以用df -i查看inode的总数和已经使用的数量，当inode节点用完后，就无法创建新文件。

linux系统在内部使用inode号码来识别文件，文件名只是便于用户可读性。读取文件分为三个步骤：1， 根据文件路径名找到inode号码。2. 根据inode号码找到inode信息，读取block位置。3. 根据block信息读取磁盘文件。 ls -i 可以读取文件的iNode号。

### 应用
硬链接， 目标文件与源文件具有相同的inode号码。其实相当于与文件的一个别名，其实是指向同一个inode节点的。删除硬链接会减少inode的链接数。 ln source_file target_file

软链接，目标文件中包含源文件的路径，访问目标文件时，读取到源文件的路径，从而访问源文件。两者具有不同的inode节点信息。ln -s source_file target_file.

### Share
最近看到专栏里一篇文章，觉得里边有个想法很好。我们在学习一门技术的时候，需要从不同角度去理解这个技术。比如常规的可能就是上来就看各种技术细节，学习各种技巧，虽然上手快，能够很快使用。这种方式比较容易沉迷于技术的细节当中，无法一窥全貌。可能学会了各种技能，但是不能有效的融汇贯通。或者技术比较复杂，就搞不清楚这些技术有什么用。

作者认为，一个框架，一个工具的出现都是为了解决现实生产中的问题，因此需要先从整体上把握这个技术是要解决什么问题，通过什么样的方式去解决这个问题，然后去理解解决这些问题的难点在哪里，作者是什么思路。

这些发明创造技术大神也不是拍脑袋就能想出解决方案的，首先是识别问题，识别问题的困难点，然后根据以往的解决问题的思路，寻找一些具有共性的方法，加上一些创新，结合实际生产环境中的一些条件，来达到解决问题，优化解决方案目的。

带着发现问题，识别问题的难点，解决问题的思路这种方式来学习可能是一种比较高效的方式。比如学习数据库索引，我们就要明白索引是为了解决什么问题？最主要还是为了解决大量数据下的快速检索。如何解决？通过B-tree或者hash等数据结构进行解决？为什么要选择B-tree？跟硬盘的工作特性有关。如果以中方式来学习记忆这些技术，可能比我们单纯的机械式记忆不同索引的优缺点，B-tree的优缺点可能更加有效。

这也是上文提到过对知识建立联系的一种应用。
