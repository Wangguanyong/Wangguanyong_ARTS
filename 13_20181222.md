## Algorithm
### [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)

``` c++
class Solution {
    public:
            int removeDuplicates(std::vector<int>& nums) {
                    int index = 1, top = 1;
                        size_t length = nums.size();
                            if(length < 2)
                                    {
                                                return length;
                                                    }
                                
                                while(index < length)
                                        {
                                                    if(nums[index] != nums[top - 1])
                                                                {
                                                                                nums[top] = nums[index];
                                                                                            top++;
                                                                                                    }
                                                            index++;
                                                                }
                                    
                                    nums.resize(top);    
                                        return top;
                                            }
};

```
这道题要求去除有序数组中的重复元素，并返回去除重复元素后的新的长度。并且要求只能有O(1)的空间复杂度。刚开始用了一个tmp保存当前的元素，然后与后续的元素逐个比较，当相同的时候则删除。后来在讨论区看到一个比较有意思的算法，用两个index，一个指向当前需要检查的元素，另一个指向新数组末尾的下一个元素，当当前元素与前一个元素相同时，此时需要过滤掉这个元素，对index累加，进入下一个元素，当不同时，则这个元素要保留，则将此元素复制进新数组的top位置下，同时top前进一格。

## Review
### [TCP/IP Protocol Design: Message Framing](https://www.codeproject.com/Articles/37496/TCP-IP-Protocol-Design-Message-Framing)</br>
众所周知，tcp是一个流式协议，即用tcp进行数据传输时是需要应用程序自行负责消息的边界处理的(经常听有人说粘包这个词， 其实是不准确的，tcp这一层根本就没有所谓包的概念，何来粘包一说，而且tcp书籍内也没有这个词，都是自造的一个词，影响大家的理解)。在一问一答这种场景下，如果网络条件比较好，延迟低，数据量小很大概率是发送一段数据后，对端能完整接收到这段消息，也能顺利的解析其中的内容（貌似一些tcp编程书籍内讲tcp编程基础例子就发送“hello world”,然后对端接收到这个hello world就完事了，这对初学者真是有很强的误导性，以为真实的tcp编程通信场景就是如此，这是很不好的例子）。</br>
这篇文章阐述了流式协议的特点以及初学者经典的认知错误，并且给出了两种经典的处理流式协议的消息格式设计方式：
1. 前导长度信息+内容
2. 特殊分隔符界定消息边界
前导长度信息+内容这种方式是用固定长度（一般4字节）表示长度字段，后续接要发送的信息。</br>

第二种特殊分隔符用特殊的开始和结尾标记表示一个消息。
这两种方法都有其固有缺陷，第一种方法，如果程序出现错误，比如长度字段和实际消息的长度不匹配，则会造成整个消息的解析失败，更为严重的是会造成后续消息的解析失败。因为除了长度字段外没有额外的逻辑来标志一个字段的结束。第二种方法的特殊标记也有问题，如果消息中本身就包含有特殊的间隔符， 又需要去做额外的检查工作，而本身消息处理程序是不需要检查消息内容的。</br>
因此，设计一个较为实用的协议需要结合这两者，即特定分隔符和长度相结合的方法。分隔符的作用在于恢复和检查，即收到消息的开始分隔符后即解析长度字段，然后获取制定长度的信息，然后检查结尾标记，以此来判断一个消息的完成，即便是发送程序出现错误，造成长度信息和实际长度不匹配，那么接手程序可以丢弃掉这段信息，从下一个开始字段进行重新解析。不会造成后续所有的解析失败。</br>
当然这个设计方法也不够完善，对于一些恶意的攻击者也没有防止，需要更多的设计与考虑。

## Tech
### UDP基础
UDP（User Datagram Protocol）是位于应用层之下，网络层之上的传输层，相比于tcp协议，其不具有连接性，不具有流量控制超时重传和应答机制，不保证数据一定送达，只是做尽力的传送工作，是一种不可靠的用户数据报协议。由于没有这些复杂的功能，其报文协议很简单，有源端和目的端的端口，还有长度信息及校验和。也由于其简单性，所以性能较高，在一些能够容忍丢数据丢失，但是要求高性能场景下（视频，游戏）是非常合适的。</br>
UDP由于没有连接性，因此是可以用一个socket向多个对端发送消息，但是由于这个特性，当向对端某个端口发送数据时，如果对端端口没有打开，则会触发一个错误，而且recvfrom无法返回相应的错误信息(无法区分是哪个对端有问题)，因此未连接的udp将不会返回错误信息。</br>
UDP 套接字是可以显式进行connect的，进行connect后，并不会像tcp套接字一样发生三次握手，当调用connect时设置发送消息的目的地址IP及端口信息，如果为设置本地端口，则设置一个本地端口，在此过程中并未发送任何消息给对端。</br>
进行connect的udp只能与与之连接的socket进行通信，其他udp socket发送至此的报文将被丢弃。UDP未连接时，每发送一个UDP消息将会断开套接字连接，下次发送重新连接，如果设置connect，者可以免去这一个步骤，会有效率上的提升(某些实现上)。

## Share
最近刚加入项目组，由于项目较老而且代码不规范，造成了接手上的困难，很难做一些改动。而且在改造项目的过程中，会用到公司内部的各种服务(数据库，图像识别之类)的能力，但是这类服务并没有提供一个很好的发布信息，需要向同事去拷贝相关库和头文件，也么有相关的demo及接入说明， 我试了一晚上都没有试出来其中一个服务的使用方法，第二天同事来改了一个参数就好了。这种方式非常不好，浪费了大量的时间与精力不说，如果服务有什么更改或者新功能上线，如何通知服务使用者，如何发布新的头文件及库文件等都是问题。但是公司内部好像大面积都是这种操作方式，并没有一个统一的发布方式、规范与流程，都靠大家的口口相传和复制拷贝。</br>
我觉得这些代码、资源、服务、文件的规范化发布与更新是非常重要且有意义的，可以节约大家大量的时间，避免重复且无意义的劳动，而且可以避免项目中的一些错误，毕竟人总是会犯错误的，或者不可能记住所有的事情，而这些规范化的管理工具及流程是一种很重要的辅助手段。


